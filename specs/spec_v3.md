# spec_v3 — Arc Provenance dApp (NFT-first provenance + demo generator)

Status: **Spec / MVP Demo Track**

Owner: road

## 0) Intent
Build a **high-signal demonstration** of on-chain provenance on Arc testnet using **NFTs as generic digital objects**.

Key properties:
- **On-chain truth**: provenance = contract events (no off-chain “pretend provenance”).
- **Demo-first**: assets are minted/registered by us; forks/attestations are generated by a demo procedure.
- **Institution-compatible framing**: “Registered Digital Object / Provenance Certificate”, not “sellable NFT art”.
- **Maximum visual clarity**: per-asset page shows metadata, lineage, transactions, attestations, and growth metrics.

## 1) Network
- Chain: **Arc Testnet**
- chainId: **5042002**
- RPC: `https://rpc.testnet.arc.network`
- Explorer: `https://testnet.arcscan.app`
- Gas token: native **USDC** (Arc testnet)

## 2) Current Deployed Contracts (test)
From `lib/contracts.ts`:
- **DigitalObjectNFT**: `0x87020198e7595C60b200EA80be41548F44573365`
- **ProvenanceRegistryV2**: `0xF015b52C9739Dc8D0739e7f7700eC7bbaE9B77C7`

> Note: these addresses can change across redeploys; the dApp must reference the latest addresses.

## 3) Domain Model
### 3.1 Asset
An **asset** is a tuple:
- `nftAddress` (ERC-721 contract)
- `tokenId` (uint256)

Assumption (MVP): **tokenId == assetId** (no separate ids).

### 3.2 Provenance Edge (Derivation)
A derivation (fork) is a directed edge:
- `parentId -> childId`

MVP constraint: **a child has exactly one parent** (tree), not a general DAG.

### 3.3 Attestation
An attestation is a signed on-chain statement tied to an asset.

Kinds (MVP):
- `1 SOURCE`
- `2 QUALITY`
- `3 REVIEW`
- `4 LICENSE`

Payload is off-chain; on-chain stores only hashes/refs.

## 4) Contract Interfaces (MVP)
### 4.1 ProvenanceRegistryV2 — Events
#### Derived (fork/derivation)
```solidity
event Derived(
  address indexed nft,
  uint256 indexed parentId,
  uint256 indexed childId,
  address actor,
  bytes32 ref
);
```

#### Attested
```solidity
event Attested(
  address indexed nft,
  uint256 indexed tokenId,
  address indexed attester,
  uint8 kind,
  bytes32 ref,
  bytes32 payloadHash
);
```

### 4.2 ProvenanceRegistryV2 — Methods
```solidity
function derive(address nft, uint256 parentId, uint256 childId, bytes32 ref) external;
function attest(address nft, uint256 tokenId, uint8 kind, bytes32 ref, bytes32 payloadHash) external;
```

**MVP validity rules** (expected):
- `derive` and `attest` revert if token(s) do not exist (`ownerOf` check).
- (Optional but recommended): `derive` reverts if `childId` already has a parent.

### 4.3 DigitalObjectNFT — Events
#### Minted
```solidity
event Minted(uint256 indexed tokenId, address indexed to, string seedURI);
```

#### StatsUpdated (dynamic metadata support)
```solidity
event StatsUpdated(
  uint256 indexed tokenId,
  uint32 forksOut,
  uint32 forksIn,
  uint32 attestCount,
  uint16 score,
  bytes32 ref
);
```

### 4.4 DigitalObjectNFT — Methods (used by dApp)
```solidity
function mint(address to, string seedURI) external returns (uint256 tokenId);
function ownerOf(uint256 tokenId) external view returns (address);
function tokenURI(uint256 tokenId) external view returns (string);
function stats(uint256 tokenId) external view returns (uint32 forksOut, uint32 forksIn, uint32 attestCount, uint16 score);
function totalSupply() external view returns (uint256);
```

## 5) Data Ingestion & Graph Build
### 5.1 Log Sources
The dApp MUST build provenance from **event logs**:
- `Derived` and `Attested` from **ProvenanceRegistryV2**
- `Minted` from **DigitalObjectNFT** (for catalog completeness)

### 5.2 Filtering
All provenance logs are filtered by:
- `args.nft == DigitalObjectNFT_ADDRESS` (case-insensitive)

### 5.3 Tree Constraint
The UI builds a **tree**. If multiple `Derived` edges exist for the same `childId`, behavior must be deterministic:
- Prefer the earliest blockNumber (or first seen) and mark “conflict” in debug.

### 5.4 Required Fix vs earlier approach
Catalog must include tokens that are minted but have no derivations:
- `allTokenIds = minted ∪ derivedParents ∪ derivedChildren ∪ attestedTokenIds`

### 5.5 Metrics
Per graph (global):
- `totalAssets`: unique tokenIds in scope
- `totalDerivatives`: count of `Derived`
- `totalAttestations`: count of `Attested`
- `maxDepth`: max tree depth

Per asset:
- `forksOut`: number of children
- `forksIn`: 1 if has parent else 0
- `attestCount`: number of attestations
- `uniqueAttesters`: count distinct attesters (UI-only)

## 6) UI/Visual Spec
### 6.1 Pages
1) **Home / Catalog**
- List assets discovered from chain (registered-by-events)
- Search input: contract address + optional tokenId
- “Demo generator” (dev-only) section

2) **Asset / Analysis page**
- Header: asset identifier (nft, tokenId), owner, randomart fingerprint
- NFT metadata card: name/description/image/attributes
- Metrics row: assets/derivatives/attestations/depth (scope: selected subgraph)
- Provenance tree view (parent->child)
- Attestations view per node
- Transactions table (Derived/Attested/Minted)

### 6.2 Asset Fingerprint (SSH randomart-like)
Goal: aesthetic, deterministic, non-art.

Seed:
- `seed = keccak256( nftAddress || tokenId || optional(payloadHash) )`

Render:
- randomart grid (e.g., 17×9) using seed-driven walk
- show as monospace block with a subtle border
- optional: color accent derived from seed (HSL)

### 6.3 Metadata Rendering
The UI must parse `tokenURI()` in common formats:
- `ipfs://...` (resolve via a gateway)
- `https://...` / `http://...`
- `data:application/json;base64,...`

Display:
- image if present
- attributes table
- external_url link

### 6.4 Status badges (non-normative)
- `Registered` (exists in catalog)
- `Root` vs `Derivative`
- `Attested` (attestCount>0)
- `Audited` (has kind=REVIEW attest)

## 7) Demo Procedure (manual but scripted)
### 7.1 Purpose
Generate a controlled dataset so viewers can see the graph grow.

### 7.2 UI Button (preferred)
A “Generate demo data” panel with parameters:
- `roots` (e.g., 1..5)
- `forkRange` (min/max forks per node)
- `maxDepth`
- `attestRate` (0..1)
- `delayMs`

Execution plan:
1) Mint roots (NFT.mint)
2) Grow tree: mint child + registry.derive(parent->child)
3) Attest: registry.attest on a sampled set of nodes
4) Optional: updateStats (if enabled)

### 7.3 UX note
Wallet-based execution will require multiple tx confirmations.
Mitigations:
- keep demo sizes small
- show progress and allow cancel

(Phase 1 later: add batch methods or operator-mode.)

## 8) Licensing & Payments (Phase 1+; compatible with v3)
v3 is designed to be extended to a registry-centric licensing layer:
- `requestDerivationLicense(...)` emits `DerivationRequested`
- `permit` gates `derive`
- optional fee in USDC (Arc gas-token / ERC-20)

Attesters (“auditors”) remain an attestation layer, not consensus.

## 9) Non-goals (for this spec)
- Multi-chain
- External liquidity
- Social layer
- Full legal-grade licensing semantics

## 10) Engineering Notes
- RPC log chunking is required (handle provider limits).
- Treat explorer links as convenience only; source-of-truth is logs.
- Keep all computed aggregates reproducible from logs.
